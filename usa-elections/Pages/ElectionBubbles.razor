@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Rendering
@using IgniteUI.Blazor.Controls

@inject HttpClient Http
@inject IIgniteUIBlazor IgniteUIBlazor;
@inject Infragistics.Samples.ElectionService ElectionService

<div class="igContainer" style="height: 100%">
     
        @*@if (ResultsByStates != null)
        {*@
     <GeographicMap Height="100%" Width="100%" Zoomable="true"
                    @ref="BubbleMapRef" 
                    BackgroundContent="@null">
            <GeographicSymbolSeries Name="bubbles"
                DataSource="@ResultsByStates"
                LatitudeMemberPath ="StateLocationY"
                LongitudeMemberPath="StateLocationX"
                ShowDefaultTooltip="true" 
                MarkerTemplateScript="onTemplateBubble">
            </GeographicSymbolSeries> 

     </GeographicMap>
     @*}*@
              
</div>

@code {

    private ElectionDisplayMode _DisplayMode = ElectionDisplayMode.Electoral;
    [Parameter]
    public ElectionDisplayMode DisplayMode
    {
        get { return _DisplayMode; }
        set { _DisplayMode = value; this.OnChanged("DisplayMode"); }
    }

    private bool IsMapZoomed = false;
    private bool IsMapReady = false;
    private GeographicMap BubbleMap;
    public GeographicMap BubbleMapRef
    {
        get { return BubbleMap; }
        set { BubbleMap = value; this.OnChanged("BubbleMap"); }
    }

    private List<ResultsByState> _ResultsByStates;
    [Parameter]
    public List<ResultsByState> ResultsByStates
    {
        get { return _ResultsByStates; }
        set { _ResultsByStates = value; this.OnChanged("ResultsByStates"); }
    }

    private void OnChanged(string prop)
    {
        Console.WriteLine("ElectionBubbles OnChanged... " + prop);

        if (this.BubbleMap != null && IsMapReady && this.ResultsByStates != null)
        {
            //await Task.Delay(10);
            Console.WriteLine("ElectionBubbles OnChanged... " + this.ResultsByStates.Count);
            //var bubbleBounds = new Rect(-8, -8, 12, 12);
            //if (this.BubbleMap != null)
            //    this.BubbleMap.UpdateWorldRect(bubbleBounds);

            Task.Delay(100).ContinueWith((t) => ZoomAsync());

            //await this.ShapeMap.ActualSeries[0].RenderSeriesAsync(false);
        }
        StateHasChanged();
    }

    protected override void OnInitialized()
    {
        Console.WriteLine("ElectionBubbles OnInitialized");

        DataChartInteractivityModule.Register(IgniteUIBlazor);
        GeographicMapModule.Register(IgniteUIBlazor);
    }

    public static Dictionary<string, StateLocation> StateLocations { get; set; }

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("ElectionBubbles OnInitializedAsync");

        ElectionService.Http = Http;
        await ElectionService.LoadStateLocations();

        var rand = new Random();
        var parties = new List<string> { "Republican", "Democrat", "Tossup" };
        var states = new List<ResultsByState>();

        var locations = ElectionService.StateLocations.Values.ToList();
        for (int i = 0; i < locations.Count; i++)
        {
            var location = locations[i];


            var result = new ResultsByState();
            result.ElectionMode = ElectionDisplayMode.Electoral.ToString();

            result.StateLocationX = location.X;
            result.StateLocationY = location.Y;
            result.StateSymbol = location.ID;

            result.StateHeldElections = i % 4 == 0 ? false : true;
            if (result.StateHeldElections)
            {
                var p = rand.Next(0, parties.Count); 
                result.WinnerElectors = rand.Next(5, 50);
                result.WinnerVotes = rand.Next(100000, 5000000) + rand.Next(100000, 700000);
                result.WinnerParty = parties[p];
                result.WinnerName = parties[p];

                p = rand.Next(0, parties.Count);
                result.LooserElectors = rand.Next(0, 2);
                result.LooserVotes = result.WinnerVotes * (rand.Next(1, 8) / 10.0);
                result.LooserParty = parties[p];

                var total = result.WinnerVotes + result.LooserVotes;
                result.WinnerPercentage   = result.WinnerVotes / total * 100;
                result.LooserPercentage = result.LooserVotes / total * 100;
            }

            states.Add(result);
        }

        ResultsByStates = states;

        //winnerParty[shapeIndex] = results[i].WinnerParty;
        //winnerCandidate[shapeIndex] = results[i].WinnerName;
        //winnerElectors[shapeIndex] = results[i].WinnerElectors.ToString();
        //winnerVotes[shapeIndex] = results[i].WinnerVotes.ToString();
        //winnerPercentage[shapeIndex] = results[i].WinnerPercentage.ToString();

        //var bubbleBounds = new Rect(-8, -8, 12, 12);
        //if (this.BubbleMap != null)
        //    await this.BubbleMap.UpdateWorldRectAsync(bubbleBounds);

        await Task.Delay(1);
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        //base.OnAfterRenderAsync();
        if (firstRender)
        {
            Console.WriteLine("ElectionBubbles Rendering...");
            IsMapReady = true;
            OnChanged("Rendering");

            //Zoom();

        }
        return base.OnAfterRenderAsync(firstRender);
    }

    public void Zoom()
    {
        Console.WriteLine("ElectionBubbles Zoom");
        if (BubbleMap != null)
        {
            var bubbleBounds = new Rect(-6, -6, 10, 10);
            this.BubbleMap.UpdateWorldRect(bubbleBounds);
        }
    }

    public async Task ZoomAsync()
    {
        Console.WriteLine("ElectionBubbles ZoomAsync");
        if (BubbleMap != null)
        {
            await Task.Delay(10);

            var bubbleBounds = new Rect(-6, -6, 10, 10);

            //this.BubbleMap.ZoomToGeographic(bubbleBounds);
            await this.BubbleMap.UpdateWorldRectAsync(bubbleBounds);
            await Task.Delay(10);
            this.BubbleMap.Zoomable = false;
        }

        await Task.Delay(1);
    }


}
